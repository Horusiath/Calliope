#region copyright
// -----------------------------------------------------------------------
//  <copyright file="PersistenceProtocol.cs" creator="Bartosz Sypytkowski">
//      Copyright (C) 2017 Bartosz Sypytkowski <b.sypytkowski@gmail.com>
//  </copyright>
// -----------------------------------------------------------------------
#endregion

using System;
using System.Collections.Generic;

namespace Calliope.Persistence
{
    /// <summary>
    /// Event handler. Input is the current state and an event that has been written to an
    /// event log.Output is the updated state that is set to the current state by the
    /// <see cref="EventSourcing"/> instance.
    /// </summary>
    /// <typeparam name="TState">Type of a state generated by event application.</typeparam>
    /// <typeparam name="TEvent">Type of an event applied.</typeparam>
    /// <param name="state">Latest known state to transformed by the event handler.</param>
    /// <param name="e">Event to be applied.</param>
    /// <returns></returns>
    public delegate TState EventHandler<TState, in TEvent>(TState state, TEvent e);

    /// <summary>
    /// Request handler. Input is current state and a request, output is an instruction to emit events
    /// and/or a response:
    ///
    ///  - <see cref="Respond{TState,TEvent,TResponse}"/> creates an immediate response which can be either the response to a "query"
    /// or the failure response to a "command" whose validation failed, for example.
    ///
    ///  - <see cref="Emit{TState,TEvent,TResponse}"/> returns a sequence of events to be written to an event log and a response factory
    /// to be called with the current state after all written events have been applied to it.
    /// </summary>
    /// <typeparam name="TState"></typeparam>
    /// <typeparam name="TEvent"></typeparam>
    /// <typeparam name="TRequest"></typeparam>
    /// <typeparam name="TResponse"></typeparam>
    /// <param name="state"></param>
    /// <param name="request"></param>
    /// <returns></returns>
    public delegate Emission<TState, TEvent, TResponse> RequestHandler<TState, TEvent, in TRequest, TResponse>(TState state, TRequest request);

    public abstract class Emission<TState, TEvent, TResponse>
    {
        public static Emission<TState, TEvent, TResponse> Respond(TResponse response) => new Respond<TState, TEvent, TResponse>(response);
        public static Emission<TState, TEvent, TResponse> Emit(IReadOnlyCollection<TEvent> events, Func<TState, TResponse> responseFactory) =>
            new Emit<TState, TEvent, TResponse>(events, responseFactory);
    }

    public sealed class Respond<TState, TEvent, TResponse> : Emission<TState, TEvent, TResponse>
    {
        public TResponse Response { get; }

        public Respond(TResponse response)
        {
            Response = response;
        }
    }

    public sealed class Emit<TState, TEvent, TResponse> : Emission<TState, TEvent, TResponse>
    {
        public IReadOnlyCollection<TEvent> Events { get; }
        public Func<TState, TResponse> ResponseFactory { get; }

        public Emit(IReadOnlyCollection<TEvent> events, Func<TState, TResponse> responseFactory)
        {
            if (events.Count == 0) throw new ArgumentException("Cannot emit empty event collection", nameof(events));

            Events = events;
            ResponseFactory = responseFactory;
        }
    }

    /// <summary>
    /// Event delivery protocol implemented by event logs and sources.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public abstract class Delivery<T> { }

    /// <summary>
    /// Emitted by an event log to signal recovery completion.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public sealed class Recovered<T> : Delivery<T>
    {
        public static readonly Recovered<T> Instance = new Recovered<T>();
        private Recovered() { }
    }

    /// <summary>
    /// Emitted by an event log or source to deliver an event (replayed or alive).
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public sealed class Delivered<T> : Delivery<T>
    {
        public Delivered(T data)
        {
            Data = data;
        }

        public T Data { get; }
    }

    /// <summary>
    /// Metadata and container of an event emitted by an `EventSourcing` stage.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public sealed class Emitted<T>
    {
        public string EmitterId { get; }
        public Guid EmissionId { get; }
        public T Event { get; }

        public Emitted(T @event, string emitterId, Guid emissionId)
        {
            EmitterId = emitterId;
            EmissionId = emissionId;
            Event = @event;
        }

        public Emitted(T @event, string emitterId) : this(@event, emitterId, Guid.NewGuid())
        {
        }

        public Durable<T> ToDurable(long sequenceNr) => new Durable<T>(Event, EmitterId, sequenceNr, EmissionId);
    }

    /// <summary>
    /// Metadata and container of a durable event emitted by an event log or source.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public sealed class Durable<T>
    {
        public string EmitterId { get; }
        public long SequenceNr { get; }
        public Guid EmissionId { get; }
        public T Event { get; }

        public Durable(T @event, string emitterId, long sequenceNr, Guid emissionId)
        {
            EmitterId = emitterId;
            SequenceNr = sequenceNr;
            EmissionId = emissionId;
            Event = @event;
        }
    }
}